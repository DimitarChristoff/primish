<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>primish - a MooTools prime fork for the browser, Class-based OOP in JavaScript</title>
	<link href="css/doctor.css" type="text/css" rel="stylesheet">
	
</head>
<body>

<a id="github-ribbon" href="https://github.com/DimitarChristoff/primish"><img alt="Fork me on GitHub" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

<div id="nav">
	<div class="separator"></div>
	<a title="primish - a MooTools prime fork for the browser, Class-based OOP in JavaScript" class="brand" href="#" style="background-image:url(images/newlogo.jpg)"></a>
	<div class="separator"></div>
	
		<div class="twitter extra">

			<iframe allowtransparency="true" frameborder="0" scrolling="no" style="width: 162px; height: 20px;" src="https://platform.twitter.com/widgets/follow_button.html?screen_name=D_mitar&amp;show_count=false"></iframe>
		</div>
		<div class="separator"></div>
	
	<ul id="sections"><li class="l2"><a href="#differences">Differences</a><ul><li class="l3"><a href="#differences/prime-changes">prime changes</a></li><li class="l3"><a href="#differences/emitter-changes">emitter changes</a></li><li class="l3"><a href="#differences/options">options</a></li><li class="l3"><a href="#differences/browser-support">Browser support</a></li><li class="l3"><a href="#differences/size-and-download">Size and download</a></li><li class="l3"><a href="#differences/changelog">Changelog</a></li></ul></li><li class="l2"><a href="#testimonials">Testimonials</a></li><li class="l2"><a href="#creating-a-class">Creating a Class</a><ul><li class="l3"><a href="#creating-a-class/constructor">constructor</a></li><li class="l3"><a href="#creating-a-class/extend">extend</a></li><li class="l3"><a href="#creating-a-class/implement">implement</a></li><li class="l3"><a href="#creating-a-class/parent">parent</a></li></ul></li><li class="l2"><a href="#define">Define</a></li><li class="l2"><a href="#plugins">Plugins</a><ul><li class="l3"><a href="#plugins/emitter">emitter</a></li><li class="l3"><a href="#plugins/options">options</a></li></ul></li><li class="l2"><a href="#contributing">contributing</a></li><li class="l2"><a href="#npm-usage">npm usage</a></li><li class="l2"><a href="#bower-usage">bower usage</a></li><li class="l2"><a href="#requirejs-usage">RequireJS usage</a></li><li class="l2"><a href="#license">License</a></li><li class="l2"><a href="#comments">Comments</a></li></ul>
	<div class="separator"></div>
	
		<div class="extra" id="github">
			<a href="https://github.com/DimitarChristoff/primish">Source on Github</a>
		</div>
		<div class="extra" id="github-issues">
			<a href="https://github.com/DimitarChristoff/primish/issues">Issues</a>
		</div>
	
	
		<div class="separator"></div>
		<div class="extra" id="github">
			<a href="http://travis-ci.org/DimitarChristoff/primish" class="travis">
				<img src="http://travis-ci.org/DimitarChristoff/primish.png?branch=master"></a>
		</div>

	
	<div class="extra generated">
		Generated by <a href="https://github.com/DimitarChristoff/doctor" target="_blank" title="generate documentation from markdown">Doctor, MD</a>
	</div>
</div>
<div id="content" class="container">
	<h1 id="primish">primish</h1>
<p>A prime derivative that went beyond repair. Initially a fork of <a href="https://github.com/mootools/prime/">MooTools prime</a>, now with a lot of sugar. </p>
<p>Why fork prime in the first place? Although prime is very good, it has been two years in the making and is not officially released yet. It&#39;s also written for CommonJS and it needs a fair amount of packaging, bundling of plugins and behaviours in order to make it work in a browser (via <code>browserify</code> or <code>wrapup</code>). It also tries to provide its own utilities methods and helpers, something that a lot of people have solved via <code>lodash</code> or <code>underscore</code>. It also does not try to keep the MooTools Class API / features. Primish does not only fix the module packaging (UMD!), there are considerable changes in code to make it more Classy and it is <code>bower</code>-ready and available on <code>cdnjs.com</code> for immediate use. At little over 4K in size, you get a lot of mileage for your money if you like classic OOP style code in your JavaScript.</p>
<p><a href="http://badge.fury.io/js/primish"><img src="https://badge.fury.io/js/primish.png" alt="NPM version"></a></p>
<h2 id="differences">Differences</h2>
<h3 id="differences/prime-changes">prime changes</h3>
<ul>
<li>forked from before the new prime <a href="https://github.com/mootools/prime/blob/master/index.js#L6-L11">types and object mixins</a>.</li>
<li><code>.parent()</code></li>
<li><code>.implement()</code> and <code>implement</code> mutator, like mootools. not <code>mixin</code></li>
<li><code>extend</code>, not <code>inherits</code></li>
<li><code>prime.merge()</code> shallow Object merging</li>
<li>object keys of constructor object are NOT de-referenced / cloned</li>
<li>only <code>options</code> objects are automatically de-referenced like in MooTools, other objects will point to prototype and will be mutable</li>
<li>extras from prime like utils, shell, type, etc have all been removed, recommended util library is <code>lodash</code>.</li>
<li>primish classes can have IDs for reflection like in AMD.</li>
</ul>
<h3 id="differences/emitter-changes">emitter changes</h3>
<ul>
<li><code>.emit</code> is actually <code>.trigger</code>, so it&#39;s not an <code>emitter</code> as such :)</li>
<li>no support for defered async events (see <a href="https://github.com/mootools/prime/blob/master/emitter.js#L50-L65">this</a>)</li>
<li>support for event stacking like <code>.on(&#39;foo bar baz&#39;, function(){});</code></li>
<li>support for event pseudos like <code>.on(&#39;foo:once&#39;, function(){});</code></li>
<li><code>emitter.definePseudo()</code> to allow custom pseudo events</li>
</ul>
<h3 id="differences/options">options</h3>
<ul>
<li><code>.setOptions()</code> - shallow merging of object with <code>this.options</code></li>
<li>support for emitter events via <code>onEventname</code> -&gt; <code>this.on(&#39;eventname&#39;)</code> like in MooTools 1.x</li>
</ul>
<h3 id="differences/browser-support">Browser support</h3>
<p>The main driving force behind primish is to change prime to work in a browser out of the box as well as under nodejs.
This fork changes the code to work via an UMD wrap w/o any dependencies, so it supports AMD (eg. RequireJS, Almond) as
well as simple browser exports to globals. If you don&#39;t have an AMD loader and not under NodeJS / browserify, it will
export <code>window.primish</code>, <code>window.emitter</code> and <code>window.options</code>, so be careful. Another goal has been to bring as much
MooTools 1.x sugar into classes as possible.</p>
<h3 id="differences/size-and-download">Size and download</h3>
<p>The minified packaged version weighs just 4.2K without gzipping, so a tiny footprint in any codebase.</p>
<p><a class="btn btn-large btn-primary" rel="download" target="_blank" href="./js/primish/primish-min.js">primish-min.js (4.2k)</a></p>
<h3 id="differences/changelog">Changelog</h3>
<ul>
<li>0.3.6 perf fixes for emitter.trigger, tiny doc changes, jsdoc notation</li>
<li>0.3.5 dereferencing <code>this.options</code> from protos, export of <code>primish.clone</code></li>
<li>0.3.4 fixed AMD module IDs for build to work better with bundles</li>
<li>0.3.3 requirejs 2.1.10 compatible bundles support via module ids</li>
<li>0.3.2 requirejs uglify2 build</li>
</ul>
<h2 id="testimonials">Testimonials</h2>
<p><a href="https://github.com/kentaromiura">kentaromiura</a>, mootools-core and mootools-prime developer said:</p>
<blockquote>
<p><em>I guess that when you said I&#39;ll go and make my own version of prime with, blackjack and hookers you really meant it</em></p>
</blockquote>
<p><img src="http://cdn.meme.li/instances/300x300/39768609.jpg" alt="our own"></p>
<h2 id="creating-a-class">Creating a Class</h2>
<p>To create a new Class, you simply need to do:</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;], function(primish){

    var Human = primish({
        setName: function(name){
            this.name = name;
        },
        getName: function(){
            return this.name;
        }
    });

    var Bob = new Human();
    Bob.setName(&#39;Bob&#39;);
    console.log(Bob.getName()); // &#39;Bob&#39;

});
</code></pre>
<p>You can also add a constructor method on your config object to run automatically:</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;], function(primish){

    var Human = primish({
        constructor: function(name){
            name &amp;&amp; this.setName(name);
        },
        setName: function(name){
            this.name = name;
        },
        getName: function(){
            return this.name;
        }
    });

    var Bob = new Human(&#39;Bob&#39;);
    console.log(Bob.getName()); // &#39;Bob&#39;

});
</code></pre>
<p>Here is an example that will make the name property <code>readonly</code> and  example private variables</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;], function(primish){

    var Human = (function(){
        var storage = {},
            hid = 0;

        var Human = primish({
            constructor: function(name){
                this.$hid = hid++;
                storage[this.$hid] = {};
                // disallow changes to human id
                primish.define(this, &#39;$hid&#39;, {
                    writable: false,
                    enumerable: false
                });

                primish.define(this, &#39;name&#39;, {
                    configurable: false,
                    get: function(){
                        return this.getName();
                    }
                });

                name &amp;&amp; this.setName(name);
            },
            setName: function(name){
                storage[this.$hid].name = name;
            },
            getName: function(){
                return storage[this.$hid].name;
            }
        });

        return Human;
    }());

    var Bob = new Human(&#39;Bob&#39;),
        Greg = new Human(&#39;Greg&#39;);

    console.log(Bob);
    console.log(Bob.getName()); // &#39;Bob&#39;
    console.log(Bob.name); // &#39;Bob&#39;
    Bob.name = &#39;Robert&#39;; // nope, should not change.
    console.log(Bob.name); // &#39;Bob&#39;
    Bob.$uid = Greg.$uid; // try to puncture Greg&#39;s storage
    console.log(Bob.name); // &#39;Bob&#39;

});
</code></pre>
<p>What happens behind the scenes? <code>prime</code> accepts a single argument as a config object. The object is a simple JavaScript
Object - with special keys (also referred to <code>mutator keys</code>).</p>
<p>A <code>mutator key</code> is a key:value pair that has a special meaning and is used differently by the Class constructor. The
following keys in your config object are considered <code>mutator</code>:</p>
<h3 id="creating-a-class/constructor">constructor</h3>
<p>The <code>constructor</code> method in your config object is what becomes the prime constructor. It runs automatically when you
instantiate and can accept any number of arguments, named or otherwise.</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;], function(primish){
    // have an element
    var div = document.createElement(&#39;div&#39;);
    div.setAttribute(&#39;id&#39;, &#39;myWidget&#39;);
    document.body.appendChild(div);

    var Widget = primish({
        options: {
            title: &#39;My Widget&#39;
        },
        constructor: function(el, options){
            this.element = document.getElementById(el);
            if (options &amp;&amp; Object(options) === options){
                this.options = options;
            }
            this.element.innerHTML = this.options.title;
        }
    });

    var instance = new Widget(&#39;myWidget&#39;, {
        title: &#39;Cool Widget&#39;,
        height: 300
    });

    console.log(instance.options.title); // &#39;Cool Widget&#39;
    console.log(instance.element.innerHTML); // &#39;Cool Widget&#39;
});
</code></pre>
<h4 id="class-ids">class IDs</h4>
<p>Primish also supports Class IDs (for &#39;reflection&#39;) - similar to AMD&#39;s module IDs. The first argument can be an optional
string ID, which can then be accessed via <code>instance._id</code>. When possible, these are added via <code>Object.defineProperty</code> and
are not enumerable.</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;], function(primish){

    var User = primish(&#39;Admin.User&#39;, {
        constructor: function(){
            console.log(this._id);
        }
    });

    var instance = new User();
    console.log(&#39;It looks like the instance is &#39; + instance._id);
});
</code></pre>
<p>Caveat: if your super Class has an ID but your subclass does not, it will still resolve this via the prototype chain
and may incorrectly identify your instance as the parent. Make sure you use IDs recursively if you need them.</p>
<h3 id="creating-a-class/extend">extend</h3>
<p>The special key <code>extend</code> defines what SuperClass your new Class will inherit from. It only accepts a single argument,
pointing to another Class. The resulting new Class definition will have its prototype set to the SuperClass and inherit
any of its static properties and methods via the scope chain.</p>
<p>This allows you to abstract differences between Classes without having to repeat a lot of code.</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;], function(primish){
    var Rectangle = primish({

        constructor: function(width, height){
            return this.setWidth(width).setHeight(height);
        },

        setWidth: function(width){
            this.width = width;
            return this; // allow chaining
        },

        setHeight: function(height){
            this.height = height;
            return this;
        },

        squareRoot: function(){
            return this.height * this.width;
        }

    });

    var Square = primish({

        // subclass of Rectangle
        extend: Rectangle,

        constructor: function(side){
            return this.setSide(side);
        },

        setSide: function(side){
            // both sides are the same
            this.width = this.height = side;
            return this;
        },

        setWidth: function(width){
            return this.setSide(width);
        },

        setHeight: function(height){
            return this.setSide(height);
        }

    });

    var square = new Square(30);
    square.setWidth(5); // local
    console.log(square.height); // 5
    console.log(square.squareRoot()); // from parent proto of Rectangle, 25
});
</code></pre>
<p>Changes to the parent Class are also reflected in the child Class by inheritance (unless the child has a local
implementation). This differs from when you use the <a href="#creating-a-class/implement">implement</a> directives, which copies instead.</p>
<pre class="prettyprint linenums"><code class="lang-javascript">// continued from above
Rectangle.prototype.shrink = function(){
    this.width--;
    this.height--;
    return this;
};

// square can also now call .shrink:
square.setSide(5).shrink();
square.width; // 4;
square.height; // 4
</code></pre>
<p><strong>Warning</strong>: when creating a new sub class, if you have an <code>options</code> object in the constructor and the super class also has it,
it will automatically merge them for you. This is really helpful when using the <a href="#plugins/options">options</a> mixin:</p>
<pre class="prettyprint linenums"><code class="lang-javascript">require([&#39;primish/primish&#39;], function(primish){
    var a = primish({
        options: {
            x: 1,
            y: 1
        }
    });

    var b = primish({
        extend: a,
        options: {
            z: 1
        }
    });

    console.log(new b().options);  // {x:1, y:1, z:1}
});
</code></pre>
<h3 id="creating-a-class/implement">implement</h3>
<p>The special key <code>implement</code> is used to tell prime which other Objects&#39; properties are to be <code>copied</code> into your own Class
definition. Mixins do not work via inheritance, they create a local instance of the properties.</p>
<p>When used as a property, <code>implement</code> accepts either a single Class or an array of Classes to implement.</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;], function(primish){
    // example using a small event emitter as a mixin
    var EID = 0;

    var Emitter = primish({

        on: function(event, fn){
            var listeners = this._listeners || (this._listeners = {}),
                events = listeners[event] || (listeners[event] = {});

                for (var k in events) if (events[k] === fn) return this;

                events[(EID++).toString(36)] = fn;
            return this;
        },

        trigger: function(event){
            var listeners = this._listeners, events, k, args;
            if (listeners &amp;&amp; (events = listeners[event])){
                args = (arguments.length &gt; 1) ? slice.call(arguments, 1) : [];
                for (k in events) events[k].apply(this, args);
            }
            return this;
        }

    });

    var myClass = primish({

        // implement the emitter:
        implement: [Emitter],

        doSomethingImportant: function(){
            this.trigger(&#39;important&#39;);
        }

    });

    var instance = new myClass();

    // bind some event, .on is available
    instance.on(&#39;important&#39;, function(){
        console.log(&#39;important is done&#39;);
    });

    // call the method that will fire the event.
    instance.doSomethingImportant();
});
</code></pre>
<p>There is an alternative syntax to allow <code>late implementation</code> via the <code>.mixin</code> method:</p>
<pre class="prettyprint linenums"><code class="lang-javascript">myClass.implement(new OtherClass());
// or chaining on an instance
instanceofMyClass.implement(new OtherClass2()).implement(new OtherClass3());

// late binding at proto definition also works
var myClass = primish({}).implement(new OtherClass);
</code></pre>
<p><div class="alert">Note: When a mixin is implemented, the mixin Class is instantiated (via <code>new</code>) and the methods are copied from
the instance, not the prototype. Changing the mixin prototype afterwards will not automatically make the changes available
in your Class instances (unlike when using <a href="#creating-a-class/extend">extend</a>)</div></p>
<h3 id="creating-a-class/parent">parent</h3>
<p>When <a href="#extend">extending a Class</a>, you can access methods from the super via the <code>.parent()</code> method. It expects at least
1 argument - the method name as <code>String</code>. This is synthactic sugar for saying:</p>
<p><code>this.constructor.prototype.methodname.apply(this, [arguments])</code>, where methodname is the method passed as string.</p>
<p>The parent method is borrowed from Arian&#39;s prime-util repo.</p>
<p>Here is a more comprehensive example:</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;], function(primish){
    // this example won&#39;t work w/o jQuery and ECMA5
    // assume this.$element is a jquery wrapped el.

    var Widget = primish({

        attachEvents: function(){
            this.$element.on(&#39;click&#39;, this.handleclick.bind(this));
        },
        handleClick: function(){

        },
        setTitle: function(title){
            this.$element.find(&#39;.title&#39;).text(title);
        }

    });

    var WeatherWidget = primish({

        extend: Widget,

        attachEvents: function(){
            this.parent(&#39;attachEvents&#39;); // call it on super Widget
            // do more.
            this.$element.find(&#39;input&#39;).on(&#39;blur&#39;, this.validateInput.bind(this));
        },
        validateInput: function(event){

        }

    });

    // example with shifting arguments
    var NewsWidget = primish({

        extend: Widget,

        setTitle: function(text){
            this.$element.find(&#39;.sub-heading&#39;).addClass(&#39;active&#39;);
            this.parent(&#39;setTitle&#39;, text); // passes original arg to parent.
        }

    });
});
</code></pre>
<h2 id="define">Define</h2>
<p>Define is a micro polyfill to <code>Object.defineProperty</code> - see <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN</a>. It works in conjunction with <code>Object.getOwnPropertyDescriptor</code>, which is also shimmed for older browsers.</p>
<p>This allows you to have read-only properties of objects, or private getters/setters. Example use</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;], function(primish){
    var Human = primish({

        constructor: function(name){
            this.name = name;

            // make name readonly
            primish.define(this, &#39;name&#39;, {
                writable: false,
                enumerable: true
            });
        },

        setName: function(name){
            this.name = name; // won&#39;t work in modern browsers
        }

    });

    var Bob = new Human(&#39;Bob&#39;);

    Bob.setName(&#39;Robert&#39;);

    Bob.name = &#39;Rob&#39;;

    // should be fine.
    console.info(Bob.name);
    console.assert(Bob.name === &#39;Bob&#39;);

});
</code></pre>
<h2 id="plugins">Plugins</h2>
<h3 id="plugins/emitter">emitter</h3>
<p>The Emitter class can work either as a <a href="#creating-a-class/implement">mixin</a> or as a standalone Class instance. It provides any Class that uses it with 3 methods it can call:</p>
<ul>
<li><code>.on(event, callback)</code> - subscribes to <code>String(event)</code> and runs <code>callback</code> when fired.</li>
<li><code>.off(event, callback)</code> - removes specific subscription to <code>String(event)</code> by exact reference to <code>callback</code>. Removing events requires you to be able to pass on the original bound callback.</li>
<li><code>.trigger(event, [Optional arguments])</code> - fires <code>String(event)</code> and optionally passes arguments to the callback</li>
</ul>
<p>By default, the scope of <code>this</code> in any event callback function will be the object that fired it, not the subscriber. If you want to keep scope bound to your local instance, you need to use <code>Function.prototype.bind</code> (if ES5Shim is being used) or <code>_.bind</code> (lodash or underscore), which is probably safer.</p>
<h4 id="using-events">Using events</h4>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;, &#39;primish/emitter&#39;], function(primish, emitter){
    // this example won&#39;t run w/o ECMA5 Function.prototype.bind

    var someController = new (primish({
        implement: [emitter]
    }))();

    var Human = primish({
        implement: [Emitter],
        constructor: function(){
            this.attachEvents();
        },
        eat: function(energy){
            this.energy += energy;
            // fire an event, passing how much and new energy level
            this.trigger(&#39;eat&#39;, [energy, this.energy]);
        },
        attachEvents: function(){
            // subscribe to another instance&#39;s init event
            someController.on(&#39;init&#39;, this.initialize.bind(this));

            // example of an event that gets removed after a single run
            this.boundFetch = this.dataFetched.bind(this);
            someController.on(&#39;fetch&#39;, this.boundFetch);
        },
        initialize: function(){
            // this will only run after the controller fires init, this = self.
            console.log(&#39;ready to do stuff&#39;);
        },
        dataFetched: function(){
            // should only run once and unsubscribe
            // do stuff
            console.log(&#39;we have data&#39;);

            // remove the event by passing reference to the saved bound function
            this.off(&#39;fetch&#39;, this.boundFetch);
            delete this.boundFetch;
        }
    });

    var Bob = new Human();
    someController.trigger(&#39;init&#39;);
    setTimeout(function(){
        someController.trigger(&#39;fetch&#39;);
    }, 1000);
});
</code></pre>
<p>You can also use <strong>named anonymous functions</strong> to remove your own event in a hurry:</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;, &#39;primish/emitter&#39;], function(primish, emitter){
    var Human = primish({
        implement: [emitter],
        constructor: function(){
            this.on(&#39;hi&#39;, function hiEvent(){
                console.log(&#39;running callback&#39;);
                this.off(&#39;hi&#39;, hiEvent);
            });
        }
    });

    var h = new Human();
    h.trigger(&#39;hi&#39;).trigger(&#39;hi&#39;); // should only console.log once

    // or simply use the :once pseudo
    h.on(&#39;bye:once&#39;, function(){
        console.log(&#39;bye&#39;);
    });

    h.trigger(&#39;bye&#39;);
    h.trigger(&#39;bye&#39;); // won&#39;t do anything
});
</code></pre>
<p>There is also syntactic sugar available for adding more than one event to the same callback:</p>
<pre class="prettyprint linenums"><code class="lang-javascript">var cb = function(){
};

model.on(&#39;change fetch create&#39;, cb); // any of change, fetch or create events fire the same handler
</code></pre>
<h4 id="definepseudo">definePseudo</h4>
<p>Emitter supports <code>pseudo events</code>, similar in style to CSS pseudos. For instance: <code>load:once</code> is a <code>load</code> event with a <code>once</code> pseudo.</p>
<p>By default, emitter ships with <code>once</code> pre-defined - which will run an event callback once only, then unbind itself.</p>
<p>It exposes an API to define custom pseudos on the emitter object.</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;, &#39;primish/emitter&#39;], function(primish, emitter){

    var user = {
        role: &#39;tester&#39;
    };

    // definePseudo takes 2 arguments - base event name and fn callback
    emitter.definePseudo(&#39;admin&#39;, function(eventName, fn){
        // need to return a function
        return function(){
            // eg, check if user.role is admin
            if (user.role === &#39;admin&#39;){
                fn.apply(this, arguments);
            }
        };
    });

    var e = new emitter();

    e.on(&#39;load:once&#39;, function(){
        console.log(&#39;loaded, should see this once&#39;);
    });

    e.on(&#39;test:admin&#39;, function(){
        console.log(&#39;this should only run when user.role === &quot;admin&quot;&#39;);
    });

    // once
    e.trigger(&#39;load&#39;);
    e.trigger(&#39;load&#39;);

    // at the moment, role is wrong, so this won&#39;t fire
    e.trigger(&#39;test&#39;);

    user.role = &#39;admin&#39;;
    e.trigger(&#39;test&#39;); // test:admin cb will now run
});
</code></pre>
<h3 id="plugins/options">options</h3>
<p>A small utility mixin from Arian&#39;s prime-util that allows easy object merge of an Object into <code>this.object</code> from right to left. If emitter is also mixed-in, it will automatically add events prefixed by <code>on</code> and camelcased, eg, <code>onReady: function(){}</code>.</p>
<pre class="prettyprint linenums"><code class="lang-ace">require([&#39;primish/primish&#39;, &#39;primish/emitter&#39;, &#39;primish/options&#39;], function(primish, emitter, options){
    var Human = primish({
        options: {
            name: &#39;unknown&#39;
        },
        implement: [options, emitter],
        constructor: function(options){
            this.setOptions(options);
            this.trigger(&#39;ready&#39;);
        }
    });

    var bob = new Human({
        name: &#39;Bob&#39;,
        surname: &#39;Roberts&#39;,
        onReady: function(){
            console.log(this.options.name, this.options.surname);
            // this.options.onReady won&#39;t be added.
        }
    });
});
</code></pre>
<h2 id="contributing">contributing</h2>
<p>To install locally, clone the repo and setup:</p>
<pre><code class="lang-sh">$ git clone https://github.com/dimitarchristoff/primish.git
$ cd primish/

# pull the deps
$ npm install

# run the tests
$ npm test

# generate docs and make a new build
$ npm install -g grunt-cli
$ grunt
$ cd dist
$ python -m SimpleHTTPServer
$ open http://localhost:8000

# just generate a new build
$ grunt requirejs:build
</code></pre>
<h2 id="npm-usage">npm usage</h2>
<p>You can install it via npm by simply doing:</p>
<pre><code class="lang-sh">$ npm install primish --save
</code></pre>
<p>Then to access it in a nodejs script:</p>
<pre class="prettyprint linenums"><code class="lang-javascript">var prime = require(&#39;primish&#39;),
    emitter = require(&#39;primish/emitter&#39;);

var foo = primish({

    implement: emitter

}); // etc.
</code></pre>
<h2 id="bower-usage">bower usage</h2>
<p>To install it as a bower component, simply do:</p>
<pre><code class="lang-sh">$ bower install primish --save
</code></pre>
<h2 id="requirejs-usage">RequireJS usage</h2>
<p>Primish is compatible with RequireJS 2.1.10 bundles. Here&#39;s an example require config that lets you use the minified primish
file and require all sub modules later:</p>
<pre class="prettyprint linenums"><code class="lang-javascript">require.config({
    bundles: {
        &#39;bower_components/primish/primish-min&#39;: [
            &#39;primish/primish&#39;,
            &#39;primish/emitter&#39;,
            &#39;primish/options&#39;
        ]
    }
});

require([
    &#39;primish/primish&#39;,
    &#39;primish/options&#39;,
    &#39;primish/emitter&#39;
], function(primish, options, emitter){
    // should see one HTTP request for primish-min only for either of
    // the 3 files requested for the first time.
    var Person = primish({
        implement: [options, emitter],
        constructor: function(options){
            this.setOptions(options);
        }
    });
});
</code></pre>
<p>Have fun, examples in <code>./examples/</code> and also look at the <code>spec</code> folder (jasmine-node test runner).
Most examples in the docs are runnable, just edit the code and press <code>run</code>, then look at your console.</p>
<p>A more complex example can be seen in <a href="http://dimitarchristoff.github.io/epik/">Epik</a>, a fully fledged MVC framework
built on top of primish and lodash.</p>
<h2 id="license">License</h2>
<p>Use as you deem fit under the original <a href="https://github.com/mootools/prime/blob/master/package.json#L23">MIT license</a> for prime. Primish brings little on top of the work of the MooTools team. The documentation and examples are not covered by the license and may need to be changed.</p>

	
		<h2 id="comments">Comments</h2>
		<div class="alert" id="disqus_thread"></div>
	
</div>
<script src="js/mootools-yui-compressed.js"></script>
<script src="js/moostrap-scrollspy.js"></script>
<script src="js/prettify.js"></script>
<script src="js/lang-css.js"></script>
<script src="js/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script src="js/doctor.js"></script>
	
	<script type="text/javascript">
		var disqus_shortname = 'primish',
				disqus_title = 'primish - a MooTools prime fork for the browser, Class-based OOP in JavaScript';


		/* * * DON'T EDIT BELOW THIS LINE * * */
		(function() {
			var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
			dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
			(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
		})();
	</script>
	
</body>
</html>